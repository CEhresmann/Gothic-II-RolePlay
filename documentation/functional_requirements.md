# Функциональные требования

Этот документ описывает функциональные требования к системе "Open Roleplay 2.0".

## 1. Аутентификация и управление аккаунтом

| ID | Требование | Примечание |
|---|---|---|
| FR-AUTH-001 | Система должна предоставлять игрокам возможность привязки игрового аккаунта к аккаунту Discord. | Реализуется через связку G2O сервер -> API -> Discord бот. |
| FR-AUTH-002 | Система должна генерировать уникальный, временный код для каждой сессии привязки. | Код имеет ограниченный срок жизни. |
| FR-AUTH-003 | Система должна позволять игроку запросить новый код, если предыдущий истек или был утерян. | |
| FR-AUTH-004 | Система должна валидировать код, полученный от Discord бота. | Проверяется совпадение кода и срок его действия. |
| FR-AUTH-005 | Система не должна позволять привязывать один Discord аккаунт к нескольким игровым аккаунтам. | |
| FR-AUTH-006 | Система должна уведомлять пользователя в Discord об успешной или неуспешной привязке. | |

# 2. Игровые механики 
## 2.1 Чат

| ID | Требование | Примечание |
|---|---|---|
| FR-CHAT-001 | Система должна обрабатывать публичные текстовые сообщения от игроков. | Сообщения, не начинающиеся с `/`, по умолчанию считаются публичными. |
| FR-CHAT-002 | Система должна предоставлять различные режимы чата (например, локальный, глобальный) и позволять игроку переключаться между ними. | Реализовано в `ChatService.toggleChatMode`. |
| FR-CHAT-003 | Система должна обрабатывать команды, вводимые через `/`. | `onPlayerCommand` в `ChatController`. |
| FR-CHAT-004 | Система должна позволять игрокам отправлять приватные сообщения другим игрокам по их ID. | Реализовано командой `/pm [id] [сообщение]`. |
| FR-CHAT-005 | Система не должна позволять отправлять приватное сообщение самому себе. | Проверка `targetId == pid` в `pm.nut`. |
| FR-CHAT-006 | Система должна информировать игрока об ошибках при использовании команд (например, неверное количество аргументов). | `sendSystemMessage` с текстом ошибки. |

## 2.2 Система фракций

| ID | Требование | Примечание |
|---|---|---|
| FR-FRAC-001 | Система должна позволять определять фракции с уникальными ID и названиями. | Реализовано в `FractionLoader.nut` через `FractionEntity`. |
| FR-FRAC-002 | Каждая фракция должна содержать иерархию классов (рангов) с уникальными ID и названиями. | `FractionEntity.addClass`. |
| FR-FRAC-003 | В каждой фракции должен быть определен как минимум один класс-лидер. | `addClass` с параметром `isLeader`. |
| FR-FRAC-004 | Система должна предоставлять возможность программно назначать игроку определенную фракцию и класс. | `FractionService.setPlayerClass`. |
| FR-FRAC-005 | Система должна позволять проверять, является ли игрок лидером своей фракции. | `FractionService.isPlayerFractionLeader`. |
| FR-FRAC-006 | При изменении фракции или класса игрока, клиентская часть должна получать уведомление для обновления интерфейса. | Отправка пакета в `setPlayerClass`. |
| FR-FRAC-007 | Система должна иметь механизм разрешений (permissions) для ограничения действий в зависимости от ранга. | **Требует уточнения.** `FactionPermissions.nut` пуст. |
| FR-FRAC-008 | Система должна предоставлять игрокам способы взаимодействия с фракциями (вступление, выход, повышение). | **Требует уточнения.** `FactionController.nut` пуст. |

## 2.3 Система крафта

| ID | Требование | Примечание |
|---|---|---|
| FR-CRAFT-001 | Система должна позволять игрокам инициировать создание предмета по известному рецепту. | `CraftController` обрабатывает пакет `RequestCraft`. |
| FR-CRAFT-002 | Система должна проверять наличие и валидность рецепта перед созданием. | `craftRepository.findByResult`. |
| FR-CRAFT-003 | Система должна проверять, достаточно ли у игрока ингредиентов для создания предмета (с учетом количества). | `playerEntity.hasItem`. |
| FR-CRAFT-004 | Если для рецепта требуется определенная профессия и уровень, система должна проверять соответствие навыков игрока. | Проверка `playerEntity.professions`. |
| FR-CRAFT-005 | В случае успешной проверки всех условий, система должна удалить необходимые ингредиенты из инвентаря игрока. | `playerEntity.removeItem`. |
| FR-CRAFT-006 | После удаления ингредиентов, система должна добавить созданный предмет(ы) в инвентарь игрока. | `playerEntity.addItem`. |
| FR-CRAFT-007 | Система должна уведомлять игрока о результате операции (успех, недостаток ингредиентов, низкий уровень профессии). | `addNotification`. |

## 2.4 Система торговли

| ID | Требование | Примечание |
|---|---|---|
| FR-TRADE-001 | Система должна позволять игроку отправить другому игроку запрос на торговлю. | `TradeService.createRequest`. |
| FR-TRADE-002 | Игрок, получивший запрос, должен иметь возможность принять или отклонить его. | `TradeService.handleResponse`. |
| FR-TRADE-003 | Если запрос отклонен, торговая сессия должна быть прекращена. | `closeSession` при `accepted = false`. |
| FR-TRADE-004 | Если запрос принят, для обоих игроков должна начаться активная торговая сессия. | `session.status = TradeStatus.ACTIVE`. |
| FR-TRADE-005 | В ходе сессии каждый игрок должен иметь возможность добавлять/изменять предметы в своем торговом предложении. | `TradeService.updateOffer`. |
| FR-TRADE-006 | Каждый игрок должен подтвердить свое согласие с текущим состоянием обмена, прежде чем сделка будет завершена. | `TradeService.acceptTrade`. |
| FR-TRADE-007 | Обмен предметами должен произойти только после того, как оба игрока подтвердили сделку. | `finalizeTrade` вызывается после `session.areBothAccepted`. |
| FR-TRADE-008 | Если один из игроков отменяет сделку, выходит из игры, или умирает, торговая сессия должна быть немедленно прекращена без обмена предметами. | `closeSession` и обработчики `onPlayerDisconnect`, `onPlayerDead`. |
| FR-TRADE-009 | Система не должна позволять начинать торговлю с игроком, который уже находится в другой торговой сессии. | Проверка `hasActiveSession` в `createRequest`. |

## 2.5 Система персонажей

| ID | Требование | Примечание |
|---|---|---|
| FR-PLAYER-001 | Система должна позволять новым игрокам регистрировать аккаунт с уникальным именем и паролем. | `PlayerService.registerPlayer`. |
| FR-PLAYER-002 | Система должна безопасно хранить пароли, используя хэширование. | `Bcrypt.hash`. |
| FR-PLAYER-003 | Система не должна позволять регистрацию, если аккаунт с таким именем уже существует. | `playerRepository.findByName`. |
| FR-PLAYER-004 | Система должна позволять зарегистрированным игрокам входить в игру, используя свое имя и пароль. | `PlayerService.loginPlayer`. |
| FR-PLAYER-005 | Система должна проверять корректность введенного пароля при входе. | `Bcrypt.compare`. |
| FR-PLAYER-006 | При успешном входе система должна загружать все данные персонажа из базы данных (статы, инвентарь и т.д.). | `playerRepository.load`. |
| FR-PLAYER-007 | Система должна периодически или по триггеру (выход из игры, выключение сервера) сохранять текущее состояние персонажа в базу данных. | `PlayerService.savePlayerState`. |
| FR-PLAYER-008 | При выходе игрока из игры его данные должны быть корректно сохранены. | `PlayerService.onPlayerDisconnect`. |

## 2.6 Поведение NPC (AI)

| ID | Требование | Примечание |
|---|---|---|
| FR-AI-001 | Система должна поддерживать создание и управление различными классами NPC и монстров. | `npcClasses` в `state.nut` определяет доступные типы. |
| FR-AI-002 | Система должна позволять динамически создавать (спавнить) экземпляры NPC в игровом мире по заданным координатам. | `createMonster` и `createHuman`. |
| FR-AI-003 | Система должна позволять удалять NPC из игрового мира. | `AI_RemoveNPC`. |
| FR-AI-004 | Система должна позволять гибко настраивать поведение гуманоидных NPC через конфигурацию. | `config` в `createHuman` (может ли бродить, атаковать, говорить и т.д.). |
| FR-AI-005 | Каждый класс NPC должен реализовывать собственную логику поведения (агрессивное, пассивное, социальное). | Подразумевается наличием разных классов (AISheep, AISkeleton и т.д.). |
| FR-AI-006 | Система должна обрабатывать жизненный цикл NPC, включая их появление в мире, обновление состояния и удаление. | `AI_SpawnNPC`, `update.nut` (подразумевается), `AI_RemoveNPC`. |
